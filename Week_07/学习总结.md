# 学习总结

## 字典树
又称`Trie树`、`单词查找树`、`键树`

是一种树形结构，对于26个字母集的Tire树就是一个26叉树，所以字典树是一个N叉树，

Trie树是一种典型的空间换时间的数据结构。它的每一条边代表一个字符，每个节点都有一个布尔值，标识到此是不是一个单词。每个节点都是以根节点到此节点的边所狗的的字符串为前缀的单词的根节点。

### 核心思想
空间换时间，利用字符串的前缀来降低查询时间的开销来提交效率

### 基本性质
1. 节点本身不存在任何完整的单词，根节点不包含字符，除了根节点以外每一个节点都值包含一个字符
2. 从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串
3. 每个节点的所有子节点路径代表的字符都不相同

### 优点
1. 利用字符串的公共前缀来减少查询时间
2. 最大限度地减少无畏的字符串比较，查询效率比哈希表高

### 主要应用
用户统计和排序大量的字符串，但不仅限于字符串，所以经常被搜索引擎系统用于文本词频统计

### 时间复杂度
1. 插入
插入字符串的长度为N，每个字符需要操做一次，那么时间复杂度为 O(n)

2. 查询
与插入相同，时间复杂度为 O(n)

### Java代码实现
```java
class Trie {
    private boolean isEnd;
    private Trie[] next;

    /**
     * Initialize your data structure here.
     */
    public Trie() {
        isEnd = false;
        next = new Trie[26];
    }

    /**
     * Inserts a word into the trie.
     */
    public void insert(String word) {
        if (word == null || word.length() == 0) {
            return;
        }

        Trie curr = this;
        char[] words = word.toCharArray();
        for (int i = 0; i < words.length; i++) {
            int n = words[i] - 'a';
            if (curr.next[n] == null) {
                curr.next[n] = new Trie();
            }
            curr = curr.next[n];
        }
        curr.isEnd = true;
    }

    /**
     * Returns if the word is in the trie.
     */
    public boolean search(String word) {
        Trie node = searchPrefix(word);
        return node != null && node.isEnd;
    }

    /**
     * Returns if there is any word in the trie that starts with the given prefix.
     */
    public boolean startsWith(String prefix) {
        Trie node = searchPrefix(prefix);
        return node != null;
    }

    private Trie searchPrefix(String word) {
        Trie node = this;
        char[] words = word.toCharArray();
        for (int i = 0;i < words.length;i++) {
            node = node.next[words[i] - 'a'];
            if (node == null) {
                return null;
            }
        }
        return node;
    }
}
```

## 并查集
并查集用于处理一些不相交集合的合并及查询问题。本身保持了一组不相交的动态集合，每个集合通过一个代表来标，代表即集合中的某个成员，通常选择根做这个代表。因为每个集合会有多个元素，所以并查集也是一个N叉树的结构

### 基本操作
1. **makeSet(n)**
建立一个新的并查集，其中包含n个元素的集合。然后把每个节点初始化为自身
```
时间复杂度 O(n)
空间复杂度也是 O(n)
```

2. **unionSet(x, y)**
把`元素x`和`元素y`所在的集合合并，要求`x`和`y`所在的集合不相交，如果相交则不合并

3. **find(x)**
找到`元素x`所在的集合的代表，也就是查找元素所在集合，即根节点
```
该操作也可以用于判断两个元素是否位于同一个集合，只要将它们各自的代表比较一下即可
```

### 路径压缩
1. `find`操做
对于一个集合树来讲，它的根节点下面可以依附许多的节点，而`find`操做，是从一个节点，不停地通过parent数组向上去寻找他的根节点，这个操作相当于把路径上的节点都要遍历一遍。`压缩路径`的`目的`就是要`减少find遍历的次数`。

2. 压缩路径的目的
在尝试`find`的过程中，从底向上，如果此时访问的节点不是一个根节点，那么就把这个节点尽量往上挪一挪，减少树的层数

### Java代码模板
```java
class UnionFind {
    private int count = 0;
    private int[] parent;

    /**
     * 创建一个新的并查集
     */
    public UnionFind(int n) {
        count = n;
        parent = new int[n];
        //把每个节点初始化为自身
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
    }

    /**
     * 将元素p 和 元素q 合并
     */
    public void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ) {
            return;
        }
        parent[rootP] = rootQ;
        count--;
    }

    /**
     * 找出元素p所在的集合代表
     */
    public int find(int p) {
        while (p != parent[p]) {
            //这一步目的是路径压缩
            parent[p] = parent[parent[p]];
            p = parent[p];
        }
        return p;
    }
}
```

## 高级搜索

### 剪枝
---
当一个分支是已经处理过的，那么就可以把这个分支的结果暂存在缓存里面，不需要再重复计算。或者有些时候是一个分支不够好，是一个比较差的分支，或者是次优的分支，也可以把它剪掉

#### 剪枝的目的
剪枝属于算法优化的范畴，通常应用在 DFS 和 BFS 搜索算法中；剪枝就是寻找过滤条件，提交减少不需要的搜索路径

### 双向BFS
---
从起点和终点分别广度优先，然后在中间相遇，加快查找速度

#### Java代码模板

### 启发式搜索
---
又称`A*搜索`、`启发式搜索`，通过优先级不断搜索优先级高的节点，通常应用于`推荐算法`和`高级搜索算法`

#### 搜索方式
不再使用队列或者栈这种先入先出或先入后出的形式，而是用一个优先队列。优先队列是按照节点的优先级，也就是有些节点更可能达到我们需要的结果，就先把这些节点拿出来进行搜索。节点的优先级由`估价函数`确定

#### 估价函数
又称`优先级函数`、`启发式函数`，启发式搜索的关键点，启发式搜索优先队列优先级主要有估价函数来确定。
1. 估价函数定义 h(n)，h 对应 heuristic
2. 它用来评价哪些节点优先级更高，最优希望是搜索要找的节点
3. h(n) 会返回一个非负实数，也可以认为是从结点的n的目标结点路径的成本，这个值越大，说明这个结点越优秀，越有可能会导致最后的结果
4. 估价函数是一种告知搜索方向的方法，它提供了一种明智的方法来猜测哪个邻居节点会导向一个目标节点


## AVL树 和 红黑树
`AVL树`和`红黑树`都是平衡二叉搜索树，`AVL树`是严格意义上的平衡二叉搜索树，`红黑树`是一个近似平衡二叉搜索树

一个高度为N的二叉搜索树在最坏的情况会退化为线性表，使其操做不在是O(log n)的时间复杂度

`AVL树`和`红黑树`在`插入和删除`时`通过旋转操作`维持二叉树的平衡，把`插入、查找、删除`的时间复杂度`最好`和`最坏`的情况都`维持在O(log n)`，但是`插入和删除`时维持二叉树的平衡也会有一些时间上的开销

### AVL树
---
严格平衡二叉搜索树。保证性能的关键是保证二维纬度，即：
1. 左右子树节点都是平衡的
2. 左右子树以此类推也都是平衡的

#### 平衡因子 Balance Factor
左子树的高度减去它右子树的高度（有时相反），平衡因子的取值范围`{-1, 0, 1}`，然后再通过旋转的操做来对二叉树进行平衡

#### 旋转
旋转操做用来维持二叉树的平衡，情况分为四种：`左旋`，`右旋`，`左右旋`，`右左旋`
1. 右旋 -- 左左子树
```
            +---+                               +---+
            | 5 |                               | 3 |
            +---+                               +---+
           /     \                           /         \
        +---+   +---+                    +---+          +---+
        | 3 |   | A |   rigth rotation   | 2 |          | 5 |
        +---+   +---+   ------------->   +---+          +---+
       /     \                          /     \        /     \
    +---+   +---+                    +---+   +---+  +---+   +---+
    | 2 |   | B |                    | D |   | C |  | B |   | A |
    +---+   +---+                    +---+   +---+  +---+   +---+
   /     \
+---+   +---+
| D |   | C |
+---+   +---+
```
- 1. 左左的情况，`根节点5`平衡因子`左子树减去右子树`等于2，不在{-1, 0, 1}的范围，需要进行一次右旋
- 2. 右旋一次，`节点3`变为树新的根节点，因为二叉树每个节点只能有2个子节点，`节点3`的右子树`节点B` 大于3且小于5，所以旋转一次之后，需要把`节点B`挂到`节点5`的左子树节点

2. 左旋 -- 右右子树
```
     +---+                                  +---+
     | 3 |                                  | 5 |
     +---+                                  +---+
    /     \                              /         \
+---+      +---+                     +---+          +---+
| A |      | 5 |    left rotation    | 3 |          | 7 |
+---+      +---+    ------------>    +---+          +---+
          /     \                   /     \        /     \
       +---+   +---+             +---+   +---+  +---+   +---+
       | B |   | 7 |             | A |   | B |  | C |   | D |
       +---+   +---+             +---+   +---+  +---+   +---+
              /     \
           +---+   +---+
           | C |   | D |
           +---+   +---+
```
- 1. 左左的情况，`根节点3`平衡因子`左子树减去右子树`等于-2，不在{-1, 0, 1}的范围，需要进行一次左旋
- 2. 左旋一次，`节点5`变为树新的根节点，因为二叉树每个节点只能有2个子节点，`节点5`的左子树`节点B` 小于5且大于3，所以旋转一次之后，需要把`节点B`的挂到`节点3`的右子树节点

3. 左右旋 -- 左右子树
```
        +---+                            +---+                               +---+
        | 5 |                            | 5 |                               | 4 |
        +---+                            +---+                               +---+
       /     \                          /     \                           /         \
    +---+   +---+                    +---+   +---+                    +---+          +---+
    | 3 |   | A |                    | 4 |   | A |   right rotation   | 3 |          | 5 |
    +---+   +---+                    +---+   +---+   ------------->   +---+          +---+
   /     \                          /     \                          /     \        /     \
+---+   +---+                      +---+   +---+                  +---+   +---+  +---+   +---+
| B |   | 4 |      left rotation   | 3 |   | D |                  | B |   | C |  | D |   | A |
+---+   +---+      ------------>   +---+   +---+                  +---+   +---+  +---+   +---+
       /     \                    /     \
    +---+   +---+              +---+   +---+
    | C |   | D |              | B |   | C |
    +---+   +---+              +---+   +---+
```
- 1. 左右子树的情况，对`节点3`子树进行一次左旋
- 2. 旋转之后，变为左左子树。根据左旋的操做，需要把`节点4`的左子节点`节点C`挂到`节点3`的右子节点
- 3. 然后再根据左左子树右旋操做，对二叉树进行右旋

4. 右左旋
```
    +---+                            +---+                              +---+
    | 3 |                            | 3 |                              | 4 |
    +---+                            +---+                              +---+
   /     \                          /     \                          /         \
+---+   +---+                    +---+   +---+                   +---+          +---+
| A |   | 5 |                    | A |   | 4 |   left rotation   | 3 |          | 5 |
+---+   +---+                    +---+   +---+   ------------>   +---+          +---+
       /     \                          /     \                 /     \        /     \
    +---+   +---+                    +---+   +---+            +---+   +---+  +---+   +---+
    | 4 |   | B |   right rotation   | D |   | 5 |            | A |   | D |  | C |   | B |
    +---+   +---+   ------------->   +---+   +---+            +---+   +---+  +---+   +---+
   /     \                                  /     \
+---+   +---+                            +---+   +---+
| D |   | C |                            | C |   | B |
+---+   +---+                            +---+   +---+
```
- 1. 右左子树的情况，对`节点5`子树进行一次右旋
- 2. 旋转之后，变为右右子树。根据右旋的操做，需要把`节点4`的右子节点`节点C`挂到`节点5`的左子节点
- 3. 然后再根据右右子树左旋操做，对二叉树进行左旋

#### 缺点
1. 节点需要存储额外的信息，
2. 调整次数频繁

### 红黑树
---
近似平衡二叉搜索树。它能确保任何一个节点的左右子树高度差小于2倍

#### 需要满足的条件
1. 每个节点要么是红色，要么是黑色
2. 根节点是黑色
3. 每个叶节点（NIL节点，空节点）是黑色的
4. 不能有相邻的两个红色节点
5. 从任一节点到其每个叶子的路径都包含相同数目的黑色节点

### 总结
1. AVL树比红黑树查询更快。因为AVL是更加严格平衡的
2. 红黑树提供了更快的查询和删除操作。因为AVL树的旋转操作会更多。而且因为红黑树是一个近似平衡树，所以旋转操做会更少一点
3. AVL要存的额外信息比红黑树多。AVL要存factor和height，需要更多的内存在每个节点上。红黑树要存的额外信息比较少，它只要一个bit来存储0和1来表示黑或者红
4. 读操作多写操作少用AVL树，如果插入操作也比较多，或者插入操作和查询操作一半一半，一般来说是用红黑树。因为AVL的问题是插入和删除对树调整的比较频繁，好处是非常平衡，所以查询就快。红黑树是比较简洁也比较容易实现，常常用在一些高级语言的库里面，比如Java和C++的map、set，在DB里面，一般读会比较多，写比较少，所以DB里面一般用AVL树