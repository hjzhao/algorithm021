/**
 * 动态规划
 *
 * 思路：
 * 每找到一个 )，就把以 ) 结尾的有效括号长度记录下来
 *  那么对应 ( 的位置一定不是一个有效括号，所以记录的长度就是 0
 *  对应的状态数组为 dp
 *
 *  1. 有效括号 ()，字符串以 s[i] == ')' 结尾，且 s[i-1] == '('
 *          那么该有效括号长度为 2，
 *     如果有效括号为 ()()，那么需要把前面有效括号的长度也加上
 *          那么可以得出 dp[i] = dp[i - 2] + 2
 *  2.有效括号 (())，字符串以 s[i] == ')' 结尾，且 s[i-1] == ')'
 *      跟 i-1 的 ')' 对应的 '(' 位置为 i - dp[i - 1] -1
 *      如果 i - dp[i - 1] -1 位置是 '('
 *          那么可以得出 dp[i] = dp[i - 1] + 2
 *  3.如果有效括号为 ()(())，在计算了 (()) 的长度后，还需要加上前面 () 的长度
 *      所以只需要在【2】的基础上，加上前面的 () 长度即可
 *      前面一个 () 长度是存在 dp数组中 i - dp[i - 1] - 2 索引中
 *          所以可以得出 dp[i] = dp[i - 1] + dp[i - dp[i - 1] - 2] + 2
 *
 *
 * 所以最后的状态转移方程为
 *
 *  1. 如果括号是以 () 结尾，那么
 *      fn(i) = fn(i - 2) + 2
 *  2. 如果括号是以 )) 结尾，那么
 *      fn(i) = fn(i - 1) + fn(i - fn(i - 1) - 2) + 2
 *
 * 因为涉及到 i-1 和 i-2，代码实现需要考虑边界情况
 *
 * 代码如下：
 *  时间复杂度：因为需要遍历整个字符串一次，所以时间复杂度为 O(n)
 *  空间复杂度：需要申请一个长度为 s.length 的 状态数组，所以空间复杂度为 O(n)
 */
public class Solution_9_1 {
    public int longestValidParentheses(String s) {
        if (s == null || s.length() == 0) {
            return  0;
        }
        int maxLength = 0;
        int[] dp = new int[s.length()];
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == ')') {
                if (s.charAt(i - 1) == '(') {
                    dp[i] = (i - 2 >= 0 ? dp[i - 2] : 0) + 2;
                } else if (i - dp[i - 1] > 0 && s.charAt(i - dp[i - 1] - 1) == '(') {
                    dp[i] = dp[i - 1] + (i - dp[i - 1] - 2 >= 0 ? dp[i - dp[i - 1] - 2] : 0) + 2;
                }
                maxLength = Math.max(maxLength, dp[i]);
            }
        }
        return maxLength;
    }
}


/*
0 1 2 3 4 5 6 7 8 9
( ( ) ( ) ( ) ( ) )
0 0 2 0 4 0 6 0 8 10

dp[9 - 1] + dp[i - dp[i - 1] - 2] + 2


0 1 2 3 4 5 6 7 8 9
( ) ( ( ( ( ) ) ) )
0 2 0 0 0 0 2 4 6 10

*/