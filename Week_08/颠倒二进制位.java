
//LeetCode 190
//颠倒给定的 32 位无符号整数的二进制位。

/*
 * 示例：
 * 输入: 00000010100101000001111010011100
 * 输出: 00111001011110000010100101000000
 */

/**
 * 思路1：循环
 * 创建一个变量res单独记录结果
 * 每次获取n最低位的数字，依次从前往后排列，放到res高位
 * 比如： 0111
 * 1. 第一次取最低位的1，然后放到res最高位，得到 1000
 *      并将n右移一位得到 0011
 * 2. 第二次再取最低位的1，然后放到res次高位，得到1100
 *      并将n右移一位得到 0001
 * 3. 重复上面操做，得到最终结果
 *
 * 代码如下：
 * 时间复杂度为: 固定循环32次 O(32)， 时间复杂度为常量 O(1)
 * 空间复杂度: 申请了两个int变量, 空间复杂度也是 O(1)
 */
public class Solution1 {
    // you need treat n as an unsigned value
    public int reverseBits(int n) {
        int count = 31;
        int res = 0;
        while (count >= 0) {
            res |= (n & 1) << count;
            n = n >> 1;
            count--;
        }
        return res;
    }
}

/**
 * 思路：分治
 *
 * 假设 n=01111011
 * 1. 可以把 n 从中间分为两部分 0111 和 1011，两部分进行调换
 *      n1 = (n >> 4) & 0x0f 得到最高4位
 *      n = (n << 4) | n1
 *      可以得到 10110111，n的前4位和后4位调换位置
 * 2. 然后再把 1011 分为 10 和 11，0111 分为 01 和 11 分别进行调换
 * 3. 然后得到最终的结果
 *
 * 代码如下：
 * 时间复杂度：没用用到循环，都是位运算操做，时间复杂度 O(1)
 * 空间复杂度：没有申请新的内存空间，空间复杂度 O(1)
 */
public class Solution2 {
    // you need treat n as an unsigned value
    public int reverseBits(int n) {
        //java没有unsigned int
        //加入n是负数，位移之后需要通过 & 0x00 来消除符号位
        n = ((n >> 16) & 0x0000ffff) | (n << 16);
        n = ((n >> 8) & 0x00ff00ff) | ((n << 8) & 0xff00ff00);
        n = ((n >> 4) & 0x0f0f0f0f) | ((n << 4) & 0xf0f0f0f0);
        n = ((n >> 2) & 0x33333333) | ((n << 2) & 0xcccccccc);
        n = ((n >> 1) & 0x55555555) | ((n << 1) & 0xaaaaaaaa);
        return n;
    }
}