// 机器人在一个无限大小的网格上行走，从点 (0, 0) 处开始出发，面向北方。该机器人可以接收以下三种类型的命令：
// -2：向左转 90 度
// -1：向右转 90 度
// 1 <= x <= 9：向前移动 x 个单位长度
// 在网格上有一些格子被视为障碍物。

// 第 i 个障碍物位于网格点  (obstacles[i][0], obstacles[i][1])
// 机器人无法走到障碍物上，它将会停留在障碍物的前一个网格方块上，但仍然可以继续该路线的其余部分。
// 返回从原点到机器人所有经过的路径点（坐标为整数）的最大欧式距离的平方。

// 示例1：
//  输入: commands = [4,-1,3], obstacles = []
//  输出: 25
//  解释: 机器人将会到达 (3, 4)
// 示例2：
//  输入: commands = [4,-1,4,-2,4], obstacles = [[2,4]]
//  输出: 65
//  解释: 机器人在左转走到 (1, 8) 之前将被困在 (1, 4) 处

// 提示：
//  0 <= commands.length <= 10000
//  0 <= obstacles.length <= 10000
//  -30000 <= obstacle[i][0] <= 30000
//  -30000 <= obstacle[i][1] <= 30000
//  答案保证小于 2 ^ 31

/**
 * 吐槽：
 * 题目真坑，看了半天没看明白障碍物是怎么回事
 * 看了题解，才明白，障碍物的值是一个二维数组
 * 二维数组的值一个长度为2的数组，代表障碍物xy坐标
 * 能看出题人写文档的水平肯定不怎么样
 */



/**
 * 解题思路
 *  转向问题：
 *    1. 机器人向右或向左走，分别会向上或向下转向
 *    2. 机器人向上或向下走，分别会向左或向右转向
 *    那么转向的组合就有8种可能性
 *  解决问题思路
 *    通过 1 表示xy轴正向位移 -1 表示xy轴反向位移 0 表示xy轴无位移操做
 *    使用两个数组 分别表示机器人在 x, y 的转向
 *      1. 若机器人沿y轴正向位移
 *      那么
 *        x 方向 0
 *        y 方向 1
 *      2. 如果此时传入 -1，则机器人右转
 *      那么
 *        x 方向 1
 *        y 方向 0
 *      3. 如果再传入 -1，则机器人继续右转
 *      那么
 *        x 方向 0
 *        y 方向 -1
 *      4. 如果再传入 -1，则
 *      那么
 *        x 反向 -1
 *        y 方向 0
 *      依次循环。输入-2左转时，反之
 *    所以设定：
 *      dx = [0, 1, 0, -1]
 *      dy = [1, 0, -1, 0]
 *      每右转一次，则 dx 和 dy 的 索引+1，再 %4
 *      每左转一次，则 dx 和 dy 的 索引-1，再 %4，相当于 索引+3，再 %4
 *
 *   障碍物问题：
 *     每走一步，则检测是否有障碍物，如果无障碍物，则位移生效，如果有障碍物，则位移不生效
 *   通过 HashSet<String> 来加快查询障碍物的速度，HashSet的值，使用 当前x坐标 + "," + 当前y坐标
 *
 * 优化：
 *   因为一开始思路 HashSet 使用 String类型作为值，而String的比较比较慢
 *  参考题解后：
 *   因为xy坐标的值为int，所以可以考虑使用 int 作为 HashSet的值 来加快比较速度
 *     10000 的二进制长度为 14，那么将 当前x坐标值 向左位移 14，预留后14位用来加上 y坐标值
 *     x << 14后，位移后的二进制数后14位为0，再通过异或 y 的方式实现 +操做
 *
 * 最后代码逻辑如下：
 */
import java.util.*;
class Solution4_2 {
    public int robotSim(int[] commands, int[][] obstacles) {
        int x = 0;
        int y = 0;
        //设置移动xy方向的对应值
        int[] dx = new int[]{0, 1, 0, -1};
        int[] dy = new int[]{1, 0, -1, 0};
        int v = 0; //用来标记当前对应 dx dy的值
        Set<Long> set = new HashSet<>(); //用来存储障碍物，因为需要位移int，所以使用long
        int res = 0;
        for (int o = 0; o < obstacles.length; o++) {
            //10000 二进制长度为 14，^等同于+操做
            // << 优先级高于 ^
            set.add((long)obstacles[o][0] << 14 ^ obstacles[o][1]);
        }

        for (int i = 0; i < commands.length; i++) {
            if (commands[i] == -1) {
                v = (v + 1) % 4;
            } else if (commands[i] == -2) {
                v = (v + 3) % 4;
            } else {
                for (int j = 0; j < commands[i]; j++) {
                    int tempX = x + dx[v];
                    int tempY = y + dy[v];
                    if (set.contains((long)tempX << 14 ^ tempY)) {
                        break;
                    }
                    x = tempX;
                    y = tempY;
                }
                //因为是单一方向行走，所以可以行走完成之后计算最大距离
                res = Math.max(res, x * x + y * y);
            }
        }
        return res;
    }
}
