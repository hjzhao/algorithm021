# 学习总结

## 动态规划 DP

### wiki定义
通过递归的方式简化一个复杂问题，将其分解成更简单的子问题。动态规划需要 分治 + 最优子结构。

### 动态规划相关问题
一般是让求一个最优解，或者求一个最大值，或者求一个最少的方式。因为有最优子结构的存在，所以中间就不需要把所有的状态都保存下来，只需要存最优的状态。在使用动态规划的时候，需要证明每一步都存的最优的值，然后就能推导出全局都是最优的值，所以就引入了两个步骤，需要有`缓存` 或者是`状态的存储数组`，每一步都会把次优的状态淘汰掉，只需要保留当前这一步的最优

### 动态规划 和 递归/分治 的关系
1. 区别
没有根本上的区别，关键看有无最优子结构
```
如果没有最优子结构，说明所有的子问题都需要计算一遍，然后把最后的结果合并在一起，这也相当于分治的一种
```

2. 共性
动态规划、递归、分治，都需要找到重复子问题

3. 差异性
动态规划有最优子结构，中途可以淘汰次优解，递归、分治没有比较和淘汰次优解的过程

```
总结：
分治没有最优子结构的情况下，也可以叫做动态规划，只是每一步的解，都可以看成最优解，没有比较和淘汰的过程
```

### 解题关键点
解决动态规划需要注意以下几点
1. 找到重复性，化繁为简成为各种子问题
```
    找到最优子结构: opt[n] = best_of(opt[n-1], opt[n-2])

    需要注意的问题：
        1. 在推导后面阶段的状态的时候，我们只关心前面阶段的状态值，而不用关心这个状态是怎么一步一步推导出来的
        2. 某阶段状态一旦确定，就不受之后阶段的决策影响
    因为人脑不适合把每一步的状态都分析出来，所以要拒绝人肉递归
```

2. 定义好状态空间
```
    存储最优解的中间状态数组 opt[i]
```
相对应的分治是吧中间状态存储到了递归里面

3. 定义动态规划方程（状态转移方程）
```
    定义递推方程：
    1. 斐波那契数列递推公式：fn(i) = fn(i-1) + fn(i-2)
    2. 不同路径递推公式：fn(i,j) = fn(i+1,j) + fn(i,j+1)
```

### 总结
打破自己的思维惯性，形成机器思维，机器思维主要是寻找重复性，这是理解复杂逻辑的额关键，也是职业进阶的要点。

使用递归解题过程中，会有一些重复计算问题，可以把重复计算的结果缓存起来，这种方式叫`记忆化搜索`

### 应用
1. 爬楼梯
[爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)
```
最优子结构：opt[i] = opt[i-1] + opt[i-2]
中间状态：opt[i-1] 和 opt[i-2] 的值
递推方程：fn(n) = fn(n-1) + fn(n-2)
```

2. 不同路径
[不同路径](https://leetcode-cn.com/problems/unique-paths/)
```
最优子结构：opt[i,j] = opt[i+1,j] + opt[i,j+1]
中间状态：opt[m,n]
递推方程：fn(i,j) = fn(i+1,j) + fn(i,j+1)
```

3. 最长公共子序列
[最长公共子序](https://leetcode-cn.com/problems/longest-common-subsequence/)
```
最优子结构：
    s1[s1_i] != s2[s2_j]: opt[s1_i,s2_j] = max(opt[s1_i-1, s2_j] + opt[s1_i, s2_j - 1])
    s1[s1_i] == s2[s2_j]: opt[s1_i,s2_j] = opt[s1_i-1,s2_j-1] + 1
中间状态：opt[s1,s2]
递推方程：
    s1[i] == s2[j]: fn(s1_i,s2_j) = max(opt[s1_i-1, s2_j] + opt[s1_i, s2_j - 1])
    s1[s1_i] == s2[s2_j]: fn(s1_i,s2_j) = opt[s1_i-1, s2_j-1] + 1
```

