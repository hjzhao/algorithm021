# 学习总结

## 哈希表
又称散列表。无序。根据关键码值访问的数据结构。通过把关键码值映射到表中的一个位置来访问记录。存储使用数组。比较适合

### 关键字-散列函数-散列地址
key-value。`key(关键字)`通过`散列函数(哈希函数)`计算得出`散列地址`，散列地址对应的是数组的下标，最后访问到数组中的`value`

### 哈希碰撞
不同的key经过哈希函数的计算，也有可能得到相同的散列地址，这种情况叫哈希碰撞。

#### 哈希碰撞解决方法
1. open hashing (拉链法)
在原地址新建一个空间，然后以链表的形式插入到该空间。改方法比较常用

2. close hashing (开地址法)
遇到冲突时，顺位查找下一个空间地址，然后把值插入进去

### 时间复杂度
因为Hash表的查询、插入都是在数组上进行操作，所以其时间复杂度大多数情况下为`O(1)`。最差的情况所有的值都映射到同一个散列地址上，查询时间复杂度为`O(n)`。

## 二叉树
每个节点都有两个子树，分别是左子树和右子树。相对于链表来讲，每个节点不再有一个next指针，而是两个next指针。空树也是二叉树

### 属性特征
1. 深度
```
树中节点最大的层数
```
2. 度
```
一个节点拥有的子树个数，二叉树中不存在度大于2的节点
1. 叶子节点，节点的度为0
2. 非叶子节点，节点的度大于0
```

### 遍历方式
遍历数最常用的方式是递归。因为树有根、左子树、右子树，根据遍历的顺序不同，分为前序遍历，中序遍历，后续遍历
1. 前序遍历
    根-左-右
2. 中序遍历
    左-根-右
3. 后续遍历
    左-右-根

### 分类
#### 二叉搜索树
有序。又称二叉排序树、有序二叉树、排序二叉树

##### 性质
1. 左子树上所有节点的值均小于它根节点的值
2. 右子树上所有节点的值均大于它根节点的值
3. 左右子树也分别是二叉搜索树

##### 时间复杂度
查询、插入、删除 时间复杂度都是 O(log n)

## 堆
快速找到一堆数中的最大值或最小值，最大值和最小值只能取其一。

### 实现形式
根据实现形式可分为`大顶堆`和`小顶堆`
1. 大顶堆
    根节点最大的堆
2. 小顶堆
    根节点最小的堆

### 时间复杂度
操做堆的时间复杂度需要满足以下
1. finx-max: O(1)
2. delete-max: O(log n)
3. insert: O(log n) 或 O(1)

### 二叉堆
通过二叉树来实现的堆。

#### 性质
1. 通过完全二叉树来实现
2. 大顶堆: 树中任意节点的值总是 >= 其自子节点的值
3. 小顶堆: 树中任意节点的值总是 <= 其自子节点的值

#### 实现方式
二叉堆并非真的通过二叉树来实现，而是通过数组来实现的。
1. 第一个元素放在数组索引为0的位置
2. 索引为 i 的节点，其左节点的索引为 2*i+1
3. 索引为 i 的节点，其右节点的索引为 2*i+2

#### 操做流程
以大顶堆为例
1. 新增
```
1. 在堆(数组)的尾部添加元素
2. 然后再将添加的元素与父节点比较
3. 如果添加的元素的值大于父节点的值，则与父节点交换位置，直至走到根节点
```
2. 删除
```
将堆(数组)尾的元素替换到根节点，被替换的元素直接删掉
顶部元素与左右节点比较，与值最大的节点交换位置，直至走到最下层
```

#### 时间复杂度
1. finx-max: O(1)
2. delete-max: O(log n)
3. insert: O(log n)

## 图
相对于二叉树来讲，图是有环的

### 属性
1. 度
一个点连了多少个边，根据其进出的方向，可分为`入度`和`出度`。如果一个边是无向的，则入度=出度。
2. 边
边有方向，则是`有向`；边没有方向，则是`无向`。一个边有多长，则是边的`权重`。边有长度，则是`有权`；边没有长度，则是`无权`。

### 表示方法
1. 邻接矩阵
2. 邻接表

### 分类
1. 无向无权图
2. 无向有权图
3. 有向无权图
3. 有向有权图

### 图的常见算法
1. DFS
2. BFS