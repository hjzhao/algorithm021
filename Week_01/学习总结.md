# 学习总结

## 本周学习内容
### 预习课学习内容
#### 数据结构（把知识点切碎）
```
一维：
    数组，链表，栈，队列，双端队列，集合，map
二维：
    树，二叉树，图，堆，并查集，字典树
特殊结构：
    位运算，布隆过滤器，LRU Cache
```

#### 算法
```
分支，遍历，搜索，动态规划，二分查找，贪心算法，排序算法，Math，几何
```

#### 算法的时间复杂度和空间复杂度分析
```
1. 采用 Big O natation
3. 七种常用时间复杂度
    O(1), O(log n), O(n), O(n^2), O(n^3), O(2^n), O(n!)
4. 主定理
    分析一类有递归结构算法时间复杂度的方法
5. 空间复杂度
    算法在运行过程中临时占用存储空间大小的量度
    表示方法与时间复杂度一致
```

#### Leetcode五步刷题法
```
1. 读题+思考，5-10分钟思考题目解法
2. 5-10分钟没有思路，直接看题的解法
3. 自己写，比较多种解法之间的优劣
4. 24小时，重复刷题
5. 过一周后，重复刷题
```
最后，面试前根据需要提前安排恢复性训练

### 第一周学习内容

#### 数组、链表、跳表

##### 数组
```
1. 插入
    插入需要挪动插入位置后面的元素
    数组容量不够时，还要涉及到对数组的扩容，然后将数组里的元素，复制到新的数组里面
    时间复杂度为 O(n)
2. 删除
    删除需要挪动删除位置后面的元素
    时间复杂度为 O(n)
3. 查找
    数组直接通过内存控制器访问
    时间复杂度为 O(1)
4. 查询某个元素是否存在
    使用二分查找
    时间复杂度 O(log n)
```
总结：数组查找非常快，但是插入和删除的效率比较低

##### 链表
链表有 单链表、双向链表。单链表里面只有一个指针，指向下一个节点的地址。双向链表里面有两个指针，next指针和prev指针，next指针指向下一个元素，prev指针指向前一个元素
```
1. 单链表增加和删除
单链表在头结点增加和删除，时间复杂度为 O(1)
单链表在尾部增加和删除，因为需要遍历链表，所以时间复杂度应该是 O(n)

2. 双向链表增加和删除
双向链表会记录头结点和末尾节点的地址
双向链表在头结点增加和删除，时间复杂度为 O(1)
双向链表在尾部增加和删除，时间复杂度为 O(1)

3. 单链表和双向链表的插入和中间节点的删除
因为链表的插入和删除不需要挪动操做位置后面的节点，所以时间复杂度是 O(1)
但是实际使用中因为单链表和双向链表插入都需要遍历链表，所以时间复杂度应该是 O(n)

4. 单链表和双向链表查找
因为都需要遍历链表，所以时间复杂度应该是 O(n)

5. LRU Cache 使用的也是链表
```

##### 跳表
跳表是有序链表，用户取代平衡树的二分查找。通过升纬，在原链表的基础上，创建索引，用来增加链表的查询效率
```
1. 增加、删除、查询时间复杂度均为 O(log n)
2. 空间复杂度 O(log n)
3. 优点：原理简单，容易实现，方便扩展，效率更高
4. 现实中使用跳表，会随着元素的增加和删除，导致索引分布不均匀
5. Redis中也有使用跳表
```

#### 栈、队列、优先队列
##### 栈
无序，先入后出
```
增加和删除 因为都在栈的头部操做，所以时间复杂度为 O(1)
查询 因为无序，所以要遍历栈内元素，时间复杂度 O(n)
```

##### 队列
无序，先入先出
```
增加和删除 因为都在队列的头部和尾部操做，所以时间复杂度为 O(1) 
查询 因为无序，所以要遍历队列内元素，时间复杂度 O(n)
```

##### 双端队列
无序，同时具备栈和队列的特点，双端队列的头和尾都能进行插入和删除操作
```
增加和删除 时间复杂度 O(1)
查询 因为无序，所以要遍历队列内元素，时间复杂度 O(n)
```

##### 优先队列
按优先级排序，再按优先级取出。底层实现较为多样和复杂
```
添加 时间复杂度 O(1)
取出 时间复杂度 O(log n)
```

